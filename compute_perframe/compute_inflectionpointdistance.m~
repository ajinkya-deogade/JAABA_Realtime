%compute inflection point based on distance
function [trx]=compute_inflectionpointdistance(trx,outputfolder)
inputfilename=[outputfolder,'xhead_mm.mat'];
if ~exist(inputfilename,'file')
    [trx]=compute_spinerelevantpositions(trx,outputfolder);
end

load([outputfolder,'xhead_mm.mat'],'data')
xhead_mm=data;
load([outputfolder,'yhead_mm.mat'],'data')
yhead_mm=data;
load([outputfolder,'xtail_mm.mat'],'data')
xtail_mm=data;
load([outputfolder,'ytail_mm.mat'],'data')
ytail_mm=data;

numlarvae=size(trx,2);
inflectionpointdistance=cell(1,numlarvae);
distances=cell(1,numlarvae);
for i=1:numlarvae
    m=(yhead_mm{1,i}-ytail_mm{1,i})./(xhead_mm{1,i}-xtail_mm{1,i});
    n=(1/2)*((yhead_mm{1,i}+ytail_mm{1,i})-m.*(xhead_mm{1,i}+xtail_mm{1,i}));
    m=repmat(m,11,1);
    n=repmat(n,11,1);
    distances{1,i}=abs(m.*trx(i).xspine_mm-trx(i).yspine_mm+n)./sqrt(m.^2+1);
    [~,inflectionpointdistance{1,i}]=max(distances{1,i});
end

units=struct('num','units','den',[]);
data=inflectionpointdistance;
filename=[outputfolder, 'inflectionpointdistance.mat'];
save(filename, 'data', 'units')